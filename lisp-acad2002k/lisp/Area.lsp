;수정날짜 :2000.6.27
;작업자 :서동석
;명령어 :C:ciman () 대지구적표작성
;        C:cimaha () 대지면적 구해서 텍스트로
;수정라인:
;수정해야 할 사항 :

;단축키 관련 변수 정의 부분..end

;;; Main function
;;;
(defun ci_area (/ temp      ss        cont      ptc       aa        lup
                  ls        uctr      ci_nm     ct_ct     rad       ang
                  cep       enp       pe        ps        stp       cen_pt
                  end_an    str_an    bulge     an_area   vname     vlist
                  bit70     an1       an2       an3       pc1       e
                  elist     rad_ds    ci_osm    text_s    text_d    text_1
                  text_2    text_3    text_4    p_p1      p_p2
                  ci_oco    ci_osc    ci_snapo
                  pt_list   ps_list   ptc_list  aa_list   dl1_list  dl2_list
                  an_list   exp_list  do_line   an_line   bt_line   ci:area
                  an_form   at_line   cen_pt    str_an    end_an    rad_ds
                  cen_list  str_list  end1_list  rad_list  ct_list bmode ci_ola)

  (princ "\nArchiFree 2002 for AutoCAD LT 2002.")
  (princ "\n대지구적표 작성 명령입니다.")
  (setq ci_snapo (getvar "snapmode"))
  (setq ci_osc (getvar "dimscale"))
  (setq ci_oco (getvar "cecolor"))
  (setq lup    (getvar "luprec"))


  ;;
  ;; Internal error handler defined locally
  ;;
  (ai_err_on)
  (ai_undo_on)
  (command "_.undo" "_group")
  (cond
    ((findfile "WHGTXT.SHX")
      (setq text_d "CIHD"
            text_s "CIHS"
      )
    )	
   
    (T
     (alert "한글 글꼴이 없습니다. ")
     (setq text_d "SIM"
            text_s "SIM"
     )
    )
  )
  (setvar "blipmode" 1)
  (setvar "osmode" 0)
  (setlay an:lay)

  
  (setq cont T uctr 0 temp T)
  (while cont
    (an_do_1)
    (an_do_2)
    (an_do_3)
    (an_do_4)
    (an_do_5)
    (an_do_6)
  )

  
  (ai_err_off)
  (ai_undo_off)
  (setvar "snapmode" ci_snapo)
  (princ)
)

(defun an_do_1 (/ exploded?)
  (if (= uctr 0)
    (setq ci_nm 1)
  )
  (while temp
    (princ "\n대지경계선을 선택하십시오/<None>: ")
    (setq ss (ssget '((-4 . "<OR")
                       (0 . "ARC") (0 . "LINE") (0 . "*POLYLINE")
                      (-4 . "OR>"))))
    (cond
      ((= ss nil)
        (get_point)
      )
      (ss
        (if (= (fld_st 0 (entget (ssname ss 0))) "LWPOLYLINE")
	  (progn
	  (command "_undo" "g")
	  (command "explode" (ssname ss 0))
	  (command "_undo" "e")
	  (setq ss (ssget "p"))
	  (setq exploded? T)
	  )
        )
        (setq k        0
              ps_list  nil
              cen_list nil
              str_list nil
              end1_list nil
              rad_list nil
        )
        (while (ssname ss k)
          (setq e (ssname ss k))
          (setq elist (entget e))
          (cond
            ((= (fld_st 0 elist) "ARC")
              (setq cen_pt (fld_st 10 elist)
                    str_an (fld_st 50 elist)
                    end_an (fld_st 51 elist)
                    rad_ds (fld_st 40 elist)
              )
              (setq ps (polar cen_pt str_an rad_ds)
                    pe (polar cen_pt end_an rad_ds)
              )
              (setq ps (equal_pt ps ps_list)
                    pe (equal_pt pe ps_list)
              )
              (setq cen_list (cons cen_pt cen_list)
                    str_list (cons ps     str_list)
                    end1_list (cons pe     end1_list)
                    rad_list (cons rad_ds rad_list)
              )
              (setq ps_list  (cons ps ps_list))
              (setq ps_list  (cons pe ps_list))
            )
            ((= (fld_st 0 elist) "LINE")
              (setq ps (fld_st 10 elist) pe (fld_st 11 elist))
              (setq ps (equal_pt ps ps_list)
                    pe (equal_pt pe ps_list)
              )
              (setq ps_list (cons ps ps_list))
              (setq ps_list (cons pe ps_list))
            )
;;;	    ((= (fld_st 0 elist) "LWPOLYLINE")
;;;
;;;	     )
            ( (= (fld_st 0 elist) "POLYLINE") 
              (setq vname (entnext e))
              (setq vlist (entget vname))
              (setq bit70 (cdr (assoc 70 elist)))
              (while (= (cdr (assoc 0 vlist)) "VERTEX") 
              (setq vname (entnext vname))
                (if (= (cdr (assoc 0 (entget vname))) "VERTEX")
                  (progn
                    (setq ps      (fld_st 10 vlist)
                          ps      (equal_pt ps ps_list)
                          ps_list (cons ps ps_list)
                          bulge   (fld_st 42 vlist)
                    )
                    (if (/= bulge 0)
                      (progn
                        (setq enp (fld_st 10 (entget vname))
                              lnh (distance ps enp)
                              an1 (angle ps enp)
                              ptc (polar ps an1 (/ lnh 2))
                              pc1 (polar ptc (if (< bulge 0)
                                               (+ an1 (/ pi 2))
                                               (- an1 (/ pi 2))
                                             ) (* lnh (abs bulge) 0.5)
                                  )
                              an2 (angle ps pc1)
                              an3 (- (angle pc1 ptc) (angle pc1 ps))
                        )
                        (if (< an3 0)
                          (setq an3 (+ an3 pi pi))
                        )
                        (if (> an3 pi)
                          (setq an3 (- (* 2 pi) an3))
                        )
                        (setq cep (inters pc1 ptc
                                          ps  (polar ps (if (< bulge 0)
                                                          (- an2 an3)
                                                          (+ an2 an3)
                                                        ) lnh) nil)
                              rad (distance cep ps)
                        )
                        (setq cen_list (cons cep cen_list)
                              rad_list (cons rad rad_list)
                        )
                        (if (> bulge 0)
                          (setq str_list (cons ps  str_list)
                                end1_list (cons enp end1_list)
                          )
                          (setq str_list (cons enp str_list)
                                end1_list (cons ps  end1_list)
                          )
                        )
                      )
                    )
                  )
                )
                (setq vlist (entget vname))
                (if (= (cdr (assoc 0 vlist)) "VERTEX")
                  (setq pe      (fld_st 10 vlist)
                        pe      (equal_pt pe ps_list)
                        ps_list (cons pe ps_list)
                        bulge   (fld_st 42 vlist)
                  )
                )
              )
              (if (= (logand bit70 1) 1)
                (progn
                  (setq vname (entnext e))
                  (setq vlist (entget vname))
                  (setq ps    (fld_st 10 vlist)
                        ps    (equal_pt ps ps_list)
                  )
                  (if (/= bulge 0)
                    (progn
                      (setq lnh (distance pe ps)
                            an1 (angle pe ps)
                            ptc (polar pe an1 (/ lnh 2))
                            pc1 (polar ptc (if (< bulge 0)
                                             (+ an1 (/ pi 2))
                                             (- an1 (/ pi 2))
                                           ) (* lnh (abs bulge) 0.5)
                                )
                            an2 (angle pe pc1)
                            an3 (- (angle pc1 ptc) (angle pc1 pe))
                      )
                      (if (< an3 0)
                        (setq an3 (+ an3 pi pi))
                      )
                      (if (> an3 pi)
                        (setq an3 (- (* 2 pi) an3))
                      )
                      (setq cep (inters pc1 ptc
                                        pe  (polar pe (if (< bulge 0)
                                                        (- an2 an3)
                                                        (+ an2 an3)
                                                      ) lnh) nil)
                            rad (distance cep pe)
                      )
                      (setq cen_list (cons cep cen_list)
                            rad_list (cons rad rad_list)
                      )
                      (if (> bulge 0)
                        (setq str_list (cons pe  str_list)
                              end1_list (cons ps  end1_list)
                        )
                        (setq str_list (cons ps  str_list)
                              end1_list (cons pe  end1_list)
                        )
                      )
                    )
                  )
                  (setq ps_list (cons pe ps_list))
                  (setq ps_list (cons ps ps_list))
                )
              )
            );;; or (poliline)
          )
          (setq k (1+ k))
        )
        (if exploded? (command "_undo" ""))
        (cond
          ((and cen_list (= (length ps_list) (* 2 (length cen_list))))
            (command "_.undo" "_m")
            (setq uctr (1+ uctr))
            (setq ct_ct 0)
            (do_arc)
            (setq temp nil bt_line nil)
            (setq ct_list (cons ct_ct ct_list))
          )
          (T
            (if (>= (length ps_list) 4)
              (progn
                (setq pk_list ps_list)
                (dr_point)
              )
              (alert "대지경계선은 최소 3변이 되어야 합니다.")
            )
          )
        );cond
      )
    )
  )
  
)

(defun an_do_2 (/ a n q k p1 p2)
  (if bt_line
    (progn
      (command "_.color" co_2)
      (setq p1 (nth 0 pt_list))
      (setq a 1 q (length pt_list) k 1)
      (repeat (- (length pt_list) 3)
        (if (= (rem a 2) 0)
          (setq n (1- q) q n)
          (setq n (1+ k) k n)
        )
        (setq p2 (nth n pt_list))
        (command "_.line" p1 p2 "")
        (setq p1 p2)
        (setq a (1+ a))
      )
      (command "_.color" ci_oco)
      (setq at_line T)
    )
    (setq at_line nil)
  )
)

(defun an_do_3 (/ a n q k p1 p2 p3)
  (if at_line
    (progn
      (setq p1 (nth 0 pt_list)
            p2 (nth 1 pt_list)
            p3 (nth 2 pt_list)
            ct_ct 0
      )
      (do_area)
      (setq a 1 q (1- (length pt_list)) k 2)
      (setq p2 p3
            p3 (nth q pt_list)
      )
      (repeat (- (length pt_list) 3)
        (do_area)
        (if (= (rem a 2) 0)
          (setq n (1- q) q n)
          (setq n (1+ k) k n)
        )
        (setq p1 p2 p2 p3)
        (setq p3 (nth n pt_list))
        (setq a (1+ a))
      )
      (if cen_list
        (do_arc)
      )
      (setq ct_list (cons ct_ct ct_list))
    )
  )
)

(defun an_do_4 (/ an_yn)
  (if (= uctr 0)
    (setq do_line nil)
    (setq do_line T)
  )
  (while do_line
    (initget "Undo Yes No")
    (setq an_yn (getkword ">>> 추가할 부분이 있습니까? Undo/Yes/<No>: "))
    (cond
      ((= an_yn "Yes")
        (setq temp T do_line nil)
      )
      ((= an_yn "Undo")
        (command "_.Undo" "_B")
        (setq uctr (1- uctr))
        (setq do_line nil an_line nil bt_line nil at_line nil)
        (if (= uctr 0)
          (setq temp     T
                aa_list  nil
                dl1_list nil
                dl2_list nil
                ct_list  nil
          )
          (setq temp     nil
                ci_nm    (- ci_nm (nth 0 ct_list))
                aa_list  (member (nth (nth 0 ct_list) aa_list)  aa_list)
                dl1_list (member (nth (nth 0 ct_list) dl1_list) dl1_list)
                dl2_list (member (nth (nth 0 ct_list) dl2_list) dl2_list)
                ct_list  (member (nth 1 ct_list) ct_list)
          )
        )
      )
      (T
        (setq do_line nil an_line T)
      )
    )
  )
)

(defun an_do_5 (/ dl1 dl2 aa val n an_area ar_area ci_exp ci_val)
  (if an_line
    (progn
      (setq an_area 0 ci_eq T ar_area 0)
      (if aa_list
        (foreach n aa_list
          (setq an_area (+ n an_area))
        )
      )
      (comma an_area 3)
      (initget (+ 2 4))
      (setq ci:area (getreal (strcat ">>> 대지면적<" CVS " M2>: ")))
      (if (= ci:area nil) (setq ci:area an_area))
      (setq an_list  nil
            exp_list nil
      )
      (if (/= (setq val (- ci:area an_area)) 0)
        (progn
          (setq k 0 ci_val 0)
          (repeat (1- (length aa_list))
            (setq aa  (nth k aa_list))
            (setq aa  (+ aa (* val (/ aa an_area))))
            (if (= (type (setq dl1 (nth k dl1_list))) 'REAL)
              (setq dl2    (/ (* aa 2) dl1)
                    dl1    (comma dl1 2)
                    dl2    (comma dl2 2);(1+ (* 2 lup)))
                    ci_exp (strcat dl1 "x" dl2 "/2")
              )
              (setq dl2    (nth k dl2_list)
                    ci_exp (strcat "R=" dl1 " A=" dl2 "%%d")
              )
            )
            (setq exp_list (cons ci_exp exp_list))
            (setq ci_val   (+ aa ci_val))
            (setq aa       (comma aa 2))
            (setq an_list  (cons aa an_list))
            (setq k (1+ k))
          )
          (setq aa (- ci:area ci_val))
          (if (= (type (setq dl1 (nth k dl1_list))) 'REAL)
            (setq dl2    (/ (* aa 2) dl1)
                  dl1    (comma dl1 2)
                  dl2    (comma dl2 2);(1+ (* 2 lup)))
                  ci_exp (strcat dl1 "x" dl2 "/2")
            )
            (setq dl2    (nth k dl2_list)
                  ci_exp (strcat "R=" dl1 " A=" dl2 "%%d")
            )
          )
          (setq exp_list (cons ci_exp exp_list))
          (setq aa  (comma aa 2))
          (setq an_list (cons aa an_list))
        )
        (progn
          (setq k 0)
          (repeat (length aa_list)
            (setq aa (nth k aa_list))
            (if (= (type (setq dl1 (nth k dl1_list))) 'REAL)
              (setq dl2    (/ (* aa 2) dl1)
                    dl1    (comma dl1 2)
                    dl2    (comma dl2 2);(1+ (* 2 lup)))
                    ci_exp (strcat dl1 "x" dl2 "/2")
              )
              (setq dl2    (nth k dl2_list)
                    ci_exp (strcat "R=" dl1 " A=" dl2 "%%d")
              )
            )
            (setq exp_list (cons ci_exp exp_list))
            (setq aa  (comma aa 2))
            (setq an_list (cons aa an_list))
            (setq k (1+ k))
          )
        )
      )
      (setq an_form T)
    )
    (setq an_form nil)
  )
)

(defun an_do_6 (/ nn cn rn d1 d2 p1 p2 ang yy lx ly tp1)
  (setq nn (length an_list))
  (setvar "snapmode" 1)
  (while an_form
    (initget 1)
    (setq p1 (getpoint "산출표작성을 위한 기준점을 지정하십시요.: "))
    (initget 1)
    (setq p2 (getcorner p1 "\n다른 코너를 찍어십시오: "))
    (setq ang (angle p1 p2))
    (setq d1 (distance p1 (list (car p2) (cadr p1))))
    (setq d2 (distance p1 (list (car p1) (cadr p2))))
    (setq lx (* ci_osc 80) ly (* ci_osc 8))
    (setq cn (fix (/ d1 lx)))
    (if (= cn 0) (setq cn 1))
    (if (<= (* cn (* ci_osc 90)) d1) (setq lx (* ci_osc 90)))
    (if (= (rem nn cn) 0)
      (setq rn (+ (/ nn cn) 2))
      (setq rn (+ (fix (/ nn cn)) 2))
    )
    (if (<= (* rn (* ci_osc 10)) d2) (setq ly (* ci_osc 10)))
    (cond
      ((and (>= (rtd ang) 0) (< (rtd ang) 90))
        (setq tp1 (polar p1 (dtr 90) (* ly rn)))
      )
      ((and (>= (rtd ang) 90) (< (rtd ang) 180))
        (setq tp1 (polar p1 (dtr 180) (+ (* lx cn) (* 0.5 ci_osc (1- cn)))))
        (setq tp1 (polar tp1 (dtr 90) (* ly rn)))
      )
      ((and (>= (rtd ang) 180) (< (rtd ang) 270))
        (setq tp1 (polar p1 (dtr 180) (+ (* lx cn) (* 0.5 ci_osc (1- cn)))))
      )
      ((and (>= (rtd ang) 270) (< (rtd ang) 360))
        (setq tp1 p1)
      )
    )
    (dr_table)
    (initget "Yes No")
    (setq yy (getkword "\n>>> 이 표 형식이 마음에 듭니까? No/<Yes>: "))
    (cond
      ((= yy "No")
        (command "_.undo" "_B")
      )
      (T
        (fl_table)
        (setq an_form nil)
        (setq cont nil)
      )
    )
  )
)

(defun dr_table (/ p k)
  (command "_.undo" "_m")
  (command "_.color" co_2)
  (setvar "blipmode" 0)
  (setq p tp1 k 0)
  (repeat cn
    (setq k (1+ k))
    (command "_.line" p (polar p 0 lx) "")
    (command "_.line" (setq p (polar p (dtr 270) (- ly (* 0.5 ci_osc))))
                      (polar p 0 lx) "")
    (setq p (polar p (dtr 270) (* 0.5 ci_osc)))
    (repeat rn
      (command "_.line" p (polar p 0 lx) "")
      (setq p (polar p (dtr 270) ly))
    )
    (command "_.line" (setq p (polar tp1 0 (* (1- k) (+ lx (* 0.5 ci_osc)))))
                      (polar p (dtr 270) (* rn ly)) "")
    (command "_.line" (setq p (polar p 0 (* 10 ci_osc)))
                      (polar p (dtr 270) (* rn ly)) "")
    (command "_.line" (setq p (polar p 0
                      (if (= lx (* 80 ci_osc)) (* 45 ci_osc) (* 50 ci_osc))))
                      (polar p (dtr 270) (* rn ly)) "")
    (command "_.line" (setq p (polar p 0
                      (if (= lx (* 80 ci_osc)) (* 25 ci_osc) (* 30 ci_osc))))
                      (polar p (dtr 270) (* rn ly)) "")
    (setq p (polar tp1 0 (* k (+ lx (* 0.5 ci_osc)))))
  )
  (command "_.color" ci_oco)
  (setvar "blipmode" 1)
)

(defun fl_table (/ n       p       po      k       an_titl kk)
  (setvar "blipmode" 0)
  (setq p tp1 k 0 n 0)
  (if (not (stysearch text_d))
    (styleset text_d)
  )
  (setvar "textstyle" text_d)
  (setq an_titl "대 지 구 적 표")
  (setq p_p1 (polar p (dtr 90) (* 2 ci_osc))
        p_p2 (polar p_p1 0 (* 6 ci_osc))
  )
  (command "_.solid" p_p1 p_p2 (polar p_p1 (dtr 90) (* 6 ci_osc)) (polar p_p2 (dtr 90) (* 6 ci_osc)) "")
  (command "_.color" co_5)
  (command "_.text" (polar p_p2 0 (* 4 ci_osc))
           (* 6 ci_osc) 0 an_titl)
  (setq p (polar p 0 (* ci_osc 5))
        p (polar p (dtr 270) (- ly (* 2.5 ci_osc)))
        po p
  )
  (command "_.color" co_3)
  (if (not (stysearch text_s))
    (styleset text_s)
  )
  (setq text_1 "구분"
        text_2 "산 출 근 거"
        text_3 "면적(M2)"
        text_4 "총계"
  )
  (repeat cn
    (setq k (1+ k))
    (setvar "textstyle" text_s)
    (command "_.text" "_C" p (* 3 ci_osc) 0 text_1)
    (command "_.text" "_C" (polar p 0 
             (if (= lx (* 80 ci_osc)) (* 27.5 ci_osc) (* 30 ci_osc)))
             (* 3 ci_osc) 0 text_2)
    (command "_.text" "_C" (polar p 0 (- lx (* 17.5 ci_osc))) (* 3 ci_osc) 0
             text_3)
    (setq p (polar p (dtr 270) ly))
    (setq kk 0)
    (setvar "textstyle" "SIM")
    (while (and (< kk (1- rn)) (< n nn))
      (setq n (1+ n))
      (setq kk (1+ kk))
      (command "_.color" co_2)
      (command "_.circle" (polar p (dtr 90) (- (/ ly 2.0) (* 2.5 ci_osc)))
               (* 2.5 ci_osc))
      (command "_.color" co_3)
      (command "_.text" "_M" (polar p (dtr 90) (- (/ ly 2.0) (* 2.5 ci_osc)))
               (* 2.5 ci_osc) 0 n)
      (command "_.text" (polar p 0 (* 11 ci_osc)) "" "" (nth (1- n) exp_list))
      (command "_.text" "_R" (polar p 0 (- lx (* 9 ci_osc)))
               "" "" (nth (1- n) an_list))
      (setq p (polar p (dtr 270) ly))
    )
    (setq p (polar po 0 (* k (+ lx (* 0.5 ci_osc)))))
  )
  (setq p (polar po (dtr 270) (* ly (1- rn)))
        p (polar p 0 (* (+ (* 0.5 ci_osc) lx) (1- cn)))
  )
  (setvar "textstyle" text_s)
  (command "_.text" "_C" p (* 3 ci_osc) "" text_4)
  (setvar "textstyle" "SIM")
  (command "_.text" "_R" (polar p 0 (- lx (* 9 ci_osc)))
           (* 2.5 ci_osc) "" (comma ci:area 2))
  (setvar "blipmode" 1)
)

(defun do_area ()
  (command "_.color" co_cen)
  (setq d1 (distance p1 p2)
        d2 (distance p2 p3)
        d3 (distance p3 p1)
  )
  (cond
    ((= (max d1 d2 d3) d1)
      (setq po p3)
      (setq pt1 p1 pt2 p2)
    )
    ((= (max d1 d2 d3) d2)
      (setq po p1)
      (setq pt1 p2 pt2 p3)
    )
    ((= (max d1 d2 d3) d3)
      (setq po p2)
      (setq pt1 p3 pt2 p1)
    )
  )
  (setq ag1 (angle pt1 pt2)
        ag2 (+ ag1 (dtr 90))
  )
  (setq pb  (polar po ag2 d1))
  (setq pb  (inters pt1 pt2 po pb nil))
  (setq dl1 (/ (distance pt1 pt2) 1000)
        dl2 (/ (distance po  pb) 1000)
  )
  (setq aa  (/ (* dl1 dl2) 2))
  (setq ptc (list (/ (+ (car pt1) (car pt2)) 2)
                  (/ (+ (cadr pt1) (cadr pt2)) 2)
            )
        ptc (list (/ (+ (car po) (car ptc)) 2)
                  (/ (+ (cadr po) (cadr ptc)) 2)
            )
  )
  (setq aa  (atof (rtos aa 2 (1+ lup))))
  (setq dl1 (atof (rtos dl1 2 lup)))
  (setq dl2 (/ (* aa 2) dl1))
  (setq aa_list  (cons aa  aa_list))
  (setq dl1_list (cons dl1 dl1_list))
  (setq dl2_list (cons dl2 dl2_list))
  (setvar "blipmode" 0)
  (command "_.line" po pb "")
  (command "_.line" (setq p (polar pb ag1 (* 2.5 ci_osc)))
                    (setq p (polar p (angle pb po) (* 2.5 ci_osc)))
                    (polar p (angle pt2 pt1) (* 2.5 ci_osc)) "")
  (command "_.color" co_2)
  (command "_.circle" ptc (* 2.5 ci_osc))
  (command "_.color" co_3)
  (if (not (stysearch "sim"))
    (styleset "sim")
  )
  (setvar "textstyle" "sim")
  (command "_.text" "j" "m" ptc (* 2.5 ci_osc) "" ci_nm)
  (command "_.color" ci_oco)
  (setq ci_nm (1+ ci_nm))
  (setq ct_ct (1+ ct_ct))
  (setvar "blipmode" 1)
)

(defun do_arc (/ n rad cep stp enp ang ar ptc)
  (setvar "blipmode" 0)
  (if (not (stysearch "sim"))
    (styleset "sim")
  )
  (setvar "textstyle" "sim")
  (setq n 0)
  (repeat (length cen_list)
    (setq rad (nth n rad_list)
          cep (nth n cen_list)
          stp (nth n str_list)
          enp (nth n end1_list)
          lnh (distance stp enp)
          ptc (polar stp (angle stp enp) (/ lnh 2))
          lnv (distance cep ptc)
          anc (angle cep ptc)
    )
    (setq ang (- (angle cep enp) (angle cep stp)))
    (if (< ang 0)
      (setq ang (+ (* 2 pi) ang))
    )
    (setq ank ang)
    (setq aa (* rad rad ang 0.5))
    (if (< ang pi)
      (setq aa  (- aa (* lnh lnv 0.5))
            ptc (polar ptc anc (/ (- rad lnv) 2))
      )
      (setq aa  (+ aa (* lnh lnv 0.5))
            ptc (polar cep (+ anc pi) (/ (- rad lnv) 2))
      )
    )
    (setq aa  (/ aa 1000000)
          aa  (atof (rtos aa 2 (1+ lup)))
          rad (comma (/ rad 1000) 2)
          ank (angtos ank 0 lup)
    )
    (setq aa_list  (cons aa  aa_list)
          dl1_list (cons rad dl1_list)
          dl2_list (cons ank dl2_list)
    )
    (command "_.color" co_cen)
    (command "_.line" stp cep enp "")
    (command "_.arc" (polar cep (angle cep stp) (* 2.5 ci_osc))
                     (polar cep (if (< ang pi) anc (+ anc pi)) (* 2.5 ci_osc))
                     (polar cep (angle cep enp) (* 2.5 ci_osc)))
    (command "_.color" co_2)
    (command "_.circle" ptc (* 2.5 ci_osc))
    (command "_.color" co_3)
    (command "_.text" "j" "m" ptc (* 2.5 ci_osc) "" ci_nm)
    (command "_.color" ci_oco)
    (setq ci_nm (1+ ci_nm))
    (setq ct_ct (1+ ct_ct))
    (setq n (1+ n))
  )
  (setvar "blipmode" 1)
)

(defun dr_point (/ ns p p1 p2 kk pks lp ps pe pos)
  (command "_.undo" "_M")
  (setq uctr (1+ uctr))
  (setq ps_list (reverse ps_list))
  (setq ps (nth 0 ps_list))
  (setq pe (nth 1 ps_list))
  (setq pt_list nil)
  (setq pt_list (cons ps pt_list))
  (setq pt_list (cons pe pt_list))
  (setq ls  (length ps_list) kk 1 pk_list nil)
  (repeat (- ls 2)
    (setq kk (1+ kk))
    (setq pk_list (cons (nth kk ps_list) pk_list))
  )
  (setq ps_list (reverse pk_list))
  (setq lp  (length ps_list))
  (while (< (length pt_list) (/ ls 2.0))
    (setq pks (what_pos pe ps_list))
    (cond
      ((and (= (rem pks 2) 0) (< pks lp))
        (setq pe (nth (1+ pks) ps_list))
        (setq pt_list (cons pe pt_list))
        (an_remove)
      )
      ((and (= (rem pks 2) 1) (< pks lp))
        (setq pe (nth (1- pks) ps_list))
        (setq pt_list (cons pe pt_list))
        (an_remove)
      )
      ((= pks lp)
        (setq pt_list (reverse pt_list))
        (setq pe (nth 0 pt_list))
      )
    )
    (setq lp  (length ps_list))
  )
  (cond
    ((= (what_pos (nth 0 ps_list) pt_list) (length pt_list))
      (setq pt_list (cons (nth 0 ps_list) pt_list))
    )
    ((= (what_pos (nth 1 ps_list) pt_list) (length pt_list))
      (setq pt_list (cons (nth 1 ps_list) pt_list))
    )
  )
  (if pt_list
    (setq pt_list (reverse pt_list) temp nil bt_line T)
  )
  (setq ns 0)
  (repeat (length pt_list)
    (setq p1 (nth ns pt_list))
    (if (= ns (1- (length pt_list)))
      (setq ns -1)
    )
    (setq p2 (nth (1+ ns) pt_list))
    (setq p (list (/ (+ (car p1) (car p2)) 2)
                  (/ (+ (cadr p1) (cadr p2)) 2)
            )
    )
    (if (not (ssget p))
      (progn
        (command "_.color" co_2)
        (command "_.line" p1 p2 "")
        (command "_.color" ci_oco)
      )
    )
    (setq ns (1+ ns))
  )
)

(defun an_remove (/ kk pk_list pb_list)
  (cond
    ((< pks 2)
      (setq kk 1 pk_list nil)
      (repeat (- lp 2)
        (setq kk (1+ kk))
        (setq pk_list (cons (nth kk ps_list) pk_list))
      )
      (setq ps_list (reverse pk_list))
    )
    ((>= pks 2)
      (if (= (rem pks 2) 0)
        (cond
          ((> lp (+ 2 pks))
            (setq kk 0 pk_list nil)
            (repeat pks
              (setq pk_list (cons (nth kk ps_list) pk_list))
              (setq kk (1+ kk))
            )
            (setq pb_list (reverse pk_list))
            (setq kk (+ 2 pks) pk_list nil)
            (repeat (- (length ps_list) kk)
              (setq pk_list (cons (nth kk ps_list) pk_list))
              (setq kk (1+ kk))
            )
            (setq ps_list (append pb_list (reverse pk_list)))
          )
          ((<= lp (+ 2 pks))
            (setq kk 0 pk_list nil)
            (repeat pks
              (setq pk_list (cons (nth kk ps_list) pk_list))
              (setq kk (1+ kk))
            )
            (setq ps_list (reverse pk_list))
          )
        )
        (cond
          ((> lp (1+ pks))
            (setq kk 0 pk_list nil)
            (repeat (1- pks)
              (setq pk_list (cons (nth kk ps_list) pk_list))
              (setq kk (1+ kk))
            )
            (setq pb_list (reverse pk_list))
            (setq kk (1+ pks) pk_list nil)
            (repeat (- (length ps_list) kk)
              (setq pk_list (cons (nth kk ps_list) pk_list))
              (setq kk (1+ kk))
            )
            (setq ps_list (append pb_list (reverse pk_list)))
          )
          ((<= lp (1+ pks))
            (setq kk 0 pk_list nil)
            (repeat (1- pks)
              (setq pk_list (cons (nth kk ps_list) pk_list))
              (setq kk (1+ kk))
            )
            (setq ps_list (reverse pk_list))
          )
        )
      )
    )
  )
)

(defun get_point (/ aa_ent an_ent qq p strt pt next vpt)
  (command "_.undo" "_M")
  (setvar "osmode" 33)
  (setq strt T)
  (while strt
    (setq an_ent nil)
    (setq pt (getpoint "\n>>> 시작점을 선택하십시오: "))
    (if pt
      (setq next T pt_list (list pt) uctr (1+ uctr))
      (if (= uctr 0)
        (setq cont nil strt nil next nil at_line nil
	      do_line nil an_line nil temp nil bt_line nil an_form nil)
        (setq next nil an_line T cont nil do_line nil )
      )
    )
    (while next
      (setq vpt pt)
      (initget "Undo")
      (setq pt (getpoint pt "\n    Undo/<next point>: "))
      (cond
        ((= pt "Undo")
          (if (= (length pt_list) 1)
            (setq next nil)
            (progn
              (setq pt_list (member (nth 1 pt_list) pt_list)
                    pt (nth 0 pt_list)
              )
              (if (= (nth 0 an_ent) "OK")
                (entdel (entlast))
              )
              (setq qq 0 aa_ent nil)
              (repeat (1- (length an_ent))
                (setq qq (1+ qq))
                (setq aa_ent (cons (nth qq an_ent) aa_ent))
              )
              (setq an_ent (reverse aa_ent))
            )
          )
        )
        ((null pt)
          (if (< (length pt_list) 3)
            (progn
	       
              (alert "대지경계선은 최소 3변이 되어야 합니다.")
              (setq pt vpt)
            )
            (progn
              (setq strt nil next nil temp nil)
              (setq vpt (nth 0 pt_list)
                    pt  (nth (1- (length pt_list)) pt_list)
              )
              (setq p (list (/ (+ (car vpt) (car pt)) 2)
                            (/ (+ (cadr vpt) (cadr pt)) 2)
                      )
              )
              (if (not (ssget p))
                (progn
                  (command "_.color" co_2)
                  (command "_.line" vpt pt "")
                  (command "_.color" ci_oco)
                )
              )
            )
          )
        )
        (T
          (if (= (what_pos pt pt_list) (length pt_list))
            (progn
              (setq pt_list (cons pt pt_list))
              (setq p (list (/ (+ (car vpt) (car pt)) 2)
                            (/ (+ (cadr vpt) (cadr pt)) 2)
                      )
              )
              (if (not (ssget p))
                (progn
                  (setq an_ent (cons "OK" an_ent))
                  (command "_.color" co_2)
                  (command "_.line" vpt pt "")
                  (command "_.color" ci_oco)
                )
                (setq an_ent (cons "NO" an_ent))
              )
            )
	    (if (and (> (length pt_list) 2)
		  (equal pt (nth (1- (length pt_list)) pt_list) 0.000001)
		)
	      	
	        (progn
			  (setq strt nil next nil temp nil)
			  (setq vpt (nth 0 pt_list)
	                    pt  (nth (1- (length pt_list)) pt_list)
	              )
	              (setq p (list (/ (+ (car vpt) (car pt)) 2)
	                            (/ (+ (cadr vpt) (cadr pt)) 2)
	                      )
	              )
	              (if (not (ssget p))
	                (progn
	                  (command "_.color" co_2)
	                  (command "_.line" vpt pt "")
	                  (command "_.color" ci_oco)
	                )
	              )
	       )
	       (progn
	              (alert "이미 선택된 점이니 다른점을 선택하십시오.")
		      (setq pt vpt)
	        )
	    )
	            
          )
        )
      )
    )
  )
  (if pt_list
    (setq pt_list (reverse pt_list) temp nil bt_line T)
  )
  (setvar "osmode" 0)
)

(defun what_pos (item the_list)
  (setq pos (- (length the_list)
               (length (member item the_list)))
  )
)

(defun equal_pt (item the_list / tem uctn)
  (setq tem T uctn 0)
  (while (and tem the_list)
    (if (equal item (nth uctn the_list) 0.1)
      (setq item (nth uctn the_list)
            tem  nil
      )
      (setq uctn (1+ uctn))
    )
    (if (not (nth uctn the_list))
      (setq tem nil)
    )
  )
  item
)

(if (null an:lay) (progn (setq an:lay "AREA") (setlay an:lay)(rtnlay)))
(defun C:CIMAN () (ci_area))
(princ)



;;---------------------------------------------------------------------
(defun m:aha (/
             ang      strtpt   nextpt   ptd     ops       ;ptn
             cont     temp     tem      tem1    tem2      tem3
             uctr     uctn     uctm     lup
             aha_osm  aha_oco  aha_oli  aha_ola  aha_err  aha_oer
             aha_ost  aha_olu ss sspl )

  (setq 
        aha_osc (getvar "dimscale")
        aha_olu (getvar "luprec")
  )
  ;;
  
;;; (ai_err_on) 작업중 폴리라인의 연결로 인한 취소 에러
  (setq err:color (getvar "cecolor")
  	err:layer (getvar "clayer")
   	err:lin (getvar "celtype")
   	err:style (getvar "textstyle")
   	err:osmode (getvar "osmode")
   	err:blipmode (getvar "blipmode")
   	err:highlight (getvar "highlight")
	;err:ortho (getvar "orthomode")
	
  )
  (setvar "cmdecho" 0)
  (setvar "regenmode" 0)
  (setvar "blipmode" 0)
  
 (defun *error* (s)
   (if (= ygpark T) (command ""))
   (setq ygpark nil)
   (if (and (/= s "Function cancelled") (/= s "quit / exit abort"))
     (princ (strcat "\nError: " s))
   )
   (setvar "cmdecho" 0)
   (setvar "regenmode" 1)
   (setvar "cecolor" err:color)
   (setvar "clayer" err:layer)
   (setvar "celtype" err:lin)
   (setvar "textstyle" err:style)
   (setvar "osmode" err:osmode)
   (setvar "blipmode" err:blipmode)
   (setvar "highlight" err:highlight)
   ;(setvar "orthomode" err:ortho)
   
   (princ)
 )
;;; 에러로인한 패치 수정 여기까지...

  (ai_undo_on)
  (command "_.undo" "_group")
  
  (princ "\nArchiFree 2002 for AutoCAD LT 2002.")
  (princ "\n면적을 구하는 명령입니다.")
  
  (setq cont T temp T uctr 0)
  (while cont
   
   (if (= uctr 0)
     (progn 
       (princ "\n면적을 구할 객체를 선택하십시오/<None>: ")
       (setq ss (ssget '((-4 . "<OR")
                        (0 . "ARC") (0 . "LINE") (0 . "*POLYLINE")
                        (-4 . "OR>"))))                 
     )
   )
   (if (= ss nil)
     (progn
	    (aha_m1)
	    (aha_m2)
     )
     (progn (if (> (sslength ss) 1) (setq ss (makepoly ss)))
            (if (= (fld_st 70 (entget (ssname ss 0))) 1)
              (setq tem3 T sspl (ssget "P"))
	      (progn (prompt "\n객체가 닫혀있지 않습니다." )
		     (command "undo" "")
		     (setq tem3 nil)
	      )
	    )
     )
   )
   (if (/= tem3 nil)(aha_dd))
   (aha_ex) 
  )

  (command "_.undo" "_en")
  (ai_err_off)
  (ai_undo_off)
  (princ)
)

(defun makepoly (selection / snn )
 (setq snn (sslength selection))
 (command "_undo" "g") 
 (command "_pedit" (ssname selection 0) "y" "_j" selection "" "")
 (command "_undo" "e")
 (ssget "L")
)
(defun aha_m1 ()

  (while temp
    (setvar "osmode" 33)
    (menucmd "s=osnapb")
    (setq ygpark T)
    (if (> uctr 0)
      (if ops
        (progn
          (initget "Oops Undo")
          (setq strtpt (getpoint "\n>>> Oops/Undo/<start point>--종료시 Enter--: "))
        )
        (progn
          (initget "Remove Undo")
          (setq strtpt (getpoint "\n>>> Remove/Undo/<start point>--종료시 Enter--: "))
        )
      )
      (setq strtpt (getpoint "\n>>> Start point: "))
    )
    (setvar "osmode" 0)
    (cond
      ((= strtpt "Oops")
        (command "_.oops")
        (setq ops nil)
      )
      ((= strtpt "Remove")
        (command "_.erase" "_P" "")
        (setq ops T)
      )
      ((= strtpt "Undo")
        (command "_.undo" "_b")
        (redraw)
        (setq uctr (1- uctr))
      )
      ((null strtpt)
        (setq cont nil temp nil)
      )
      (T
        (command "_.undo" "_M")
        (command "_.pline" strtpt)
        (setq uctn 0)
        (setq temp nil tem T)
      )
    )
  )
)

(defun aha_m2 ()

  (while tem
    (setvar "osmode" 33)
    (menucmd "s=osnapb")
    (cond
      ((= uctn 0)
        (initget "Arc")
        (setq nextpt (getpoint (getvar "lastpoint") "\nArc/<next point>: "))
      )
      ((= uctn 1)
        (initget "Arc Undo")
        (setq nextpt (getpoint (getvar "lastpoint") "\nArc/Undo/<next point>: "))
      )
      (T
        (initget "Arc Close Undo")
        (setq nextpt (getpoint (getvar "lastpoint") "\nArc/Close/Undo/<next point>: "))
      )
    )
    (cond
      ((= nextpt "Undo")
        (command "_U")
        (redraw)
        (setq uctn (1- uctn))
      )
      ((= nextpt "Close")
        (command "_C")
        (setq tem nil tem3 T)
      )
      ((= nextpt "Arc")
        (command "_A" "_s")
        (princ "\nSecond point: ")
        (command pause)
        (setq tem1 T uctm 0)
        (while tem1
          (princ "\nEndpoint: ")
          (command pause)
          (setq uctm (1+ uctm)
                uctn (1+ uctn)
          )
          (if (equal (getvar "lastpoint") strtpt 0.1)
            (progn
              (command "")
              (setq tem nil tem1 nil tem3 T)
            )
            (setq tem2 T)
          )
          (while tem2
            (initget "Line Undo")
            (setq ptd (getpoint "\nLine/Undo/<second point>: "))
            (cond
              ((= ptd "Line")
                (command "_L")
                (setq tem2 nil tem1 nil)
              )
              ((= ptd "Undo")
                (command "_u")
                (setq uctm (1- uctm)
                      uctn (1- uctn)
                )
                (if (= uctm 0)
                  (setq tem2 nil tem1 nil)
                )
              )
              ((null ptd)
                (setq tem2 nil tem1 nil)
              )
              (T
                (command "_S" ptd)
                (setq tem2 nil)
              )
            )
          )
        )
      )
      ((= (type nextpt) 'LIST)
        (if (equal nextpt strtpt 0.1)
          (progn
            (command nextpt "")
            (setq tem nil tem3 T)
          )
          (progn
            (command nextpt)
            (setq uctn (1+ uctn))
          )
        )
      )
      (T
       (if (> uctn 1)
	     (progn
	       (princ "ahahah")
	       (command "C")
		   (setq tem nil tem3 T)
	     )
	     (progn
	       (command "")
	       (setq tem nil temp T tem3 nil)
	     )  
       )
        
      )
    )
  )
  (setq ygpark nil)
)
(defun aha_dd(/ dd_layer dd_color message pre_pym2)
  (setq pre_pym2 pym2)
  (if sspl
    (command "_.area" "_O" (ssname sspl 0)) ; O equal Object
    (command "_.area" "_E" (entlast)) 
  )
  (setq aha:are (/ (getvar "area") 1000000))      
  (if (/= pym2 "M2") (setq aha:are (* aha:are 0.3025)))
  (comma aha:are aha:lup)
  
  (setq 
  	old:ahaprop  aha:ahaprop	
	aha:bylayer nil
  )
  
  (setq dcl_id (ai_dcl "aha")) ; load aha.dcl
  (if (not (new_dialog "aha" dcl_id)) (exit))
  (setq message (strcat "측정된 면적은 " CVS "입니다."))  
  (if (= pym2 "M2")
    (set_tile "rd_m2" "1")
    (progn (set_tile "rd_py" "1") (set_tile "tg_insert" "1"))
  )
  (set_tile "t_top" message)
  (set_tile "ed_point" (itoa aha:lup))
  (set_tile "ed_size"  (itoa aha:the))
  (set_tile "ed_angle" (itoa aha:ang))
  ;==================================================================
  (set_tile aha_prop_type "1")    
  (@get_eval_prop aha_prop_type aha:prop)     
  (action_tile "b_name" "(@getlayer)")
  (action_tile "b_color" "(@getcolor)")
  (action_tile "color_image" "(@getcolor)")
  (action_tile "c_bylayer" "(@bylayer_do T)"); T=color or nil=linetype  
  ;==================================================================
  (action_tile "rd_m2" "(setq pym2 \"M2\")(m2_py)")
  (action_tile "rd_py" "(setq pym2 \"평\")(m2_py)")
  (action_tile "accept" "(aha_dd_ok)")
  (action_tile "cancel" "(aha_dd_cancel)")
  (start_dialog)
  (done_dialog)
)
(defun m2_py(/ message)
  (if (/= pre_pym2 pym2)
    (progn
      (if (= pym2 "M2")
	(progn
	  (set_tile "tg_insert" "0")
	  (setq aha:are (/ aha:are 0.3025))
	  (comma aha:are (atoi (get_tile "ed_point")))
          (setq message (strcat "측정된 면적은 " CVS "입니다."))
	  (set_tile "t_top" message)
	  ;(setq aha:are (/ aha:are 0.3025))
	)
	(progn
	  (set_tile "tg_insert" "1")
	  (setq aha:are (* aha:are 0.3025))
	  (comma aha:are (atoi (get_tile "ed_point")))
          (setq message (strcat "측정된 면적은 " CVS "입니다."))
	  (set_tile "t_top" message)
	  ;(setq aha:are (* aha:are 0.3025))
	)
      )
    )
 )
 (setq pre_pym2 pym2)
)  

(defun aha_dd_ok()
  (prop_save aha:prop)	
  (if (/= (get_tile "rd_m2") "0")
    (setq pym2 "M2")
    (setq pym2 "평")
  )
  (setq aha:lup (atoi (get_tile "ed_point"))
	aha:the (atoi (get_tile "ed_size"))
	aha:ang (atoi (get_tile "ed_angle"))
  )
  (if (/= (get_tile "tg_insert") "0")
    (setq unit_insert T)
    (setq unit_insert nil)
  )  
  (setvar "luprec" aha:lup)
  (done_dialog)
)
(defun aha_dd_cancel()
  (setq aha:ahaprop old:ahaprop)
  (done_dialog)
)
(defun aha_ex()
  (setvar "osmode" 0)
  (while tem3
    (initget "Dialog Undo")
    (setq ptn (getpoint (strcat "\n>>> Dialog/Undo/<면적(" pym2 ") 위치>: ")))
    (cond
      ((= ptn "Dialog")
       (aha_dd)
      )
      ((= ptn "Undo")
       (entdel (entlast))
       (redraw)
       (setq tem3 nil temp T)
      )
      ((= ptn nil)
       (setq tem3 nil temp nil cont nil)
      ) 
      (T
        (if (= sspl nil)(command "_.erase" (entlast) ""))
        (comma aha:are aha:lup)
        (set_col_lin_lay text:tprop)       

        (if (not (stysearch "CIHS")) (styleset "CIHS"))
        (setvar "textstyle" "CIHS")
        (command "_.text" "_m" ptn (* aha_osc aha:the) aha:ang
                 (if (/= pym2 "M2")
		   (if (= unit_insert T)
		     (strcat CVS "평")
		     CVS
		   )
		   (if (= unit_insert T)
		     (strcat CVS "m2")
		     CVS
		   ) 
		 )
        )
        
	
        (setq uctr (1+ uctr))
        (if sspl 
   	  (setq tem3 nil temp nil cont nil ops nil)
  	  (setq tem3 nil temp T ops T)
  	)
      )
    )
  )  
)


(if (null aha:the) (setq aha:the 3))
(if (null aha:ang) (setq aha:ang 0))
(if (null aha:lup) (setq aha:lup (getvar "luprec")))
(if (null pym2) (setq pym2 "M2"))
;======================================================
(setq text:tprop  (Prop_search "text" "text"))
(setq aha:prop '(text:tprop))

(if (null aha_prop_type) (setq aha_prop_type "rd_text"))
;======================================================
(defun C:CIMAHA () (m:aha))


(setq lfn09 1)
(princ)
